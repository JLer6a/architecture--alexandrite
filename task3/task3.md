# Архитектурное решение по трейсингу

## Мотивация

Внедрение трейсинга позволит:

    - Уменьшить количество "зависших" заказов за счёт быстрого выявления проблемных участков.
    - Сократить время на расследование инцидентов.
    - Улучшить пользовательский опыт за счёт повышения прозрачности обработки заказов.
    - Снизить вероятность потери сообщений в RabbitMQ.
    - Оптимизировать взаимодействие между системами и сократить задержки в обработке.

Бизнес-метрики, на которые повлияет трейсинг:

    - Среднее время обработки заказа.
    - Количество "зависших" заказов.
    - Уровень удовлетворённости клиентов.
    - Количество инцидентов, связанных с потерей сообщений.
    - Время на расследование и устранение инцидентов.

## Идентификация точек трейсинга

Точки, в которых заказ может зависнуть:

    - Передача заказа из интернет-магазина в CRM (проблемы с очередями сообщений RabbitMQ).
    - Расчёт стоимости в MES (время обработки модели может достигать 30 минут).
    - Передача заказа из CRM в MES (ошибки интеграции, таймауты).
    - Передача заказа из MES в CRM после завершения производства.
    - Обновление статуса заказа в БД.

Список данных для трейсинга

     - Уникальный идентификатор заказа.
     - Таймстемп события (временная метка перехода заказа в новый статус).
     - Источник события (какая система изменила статус).
     - Статус заказа до и после изменения.
     - Длительность обработки в каждом сервисе.
     - Ошибки при передаче сообщений между сервисами.
     - Метрики задержек в очередях RabbitMQ.

## Предлагаемое решение

Выбранный инструмент

Для реализации трейсинга предлагается использовать OpenTelemetry, так как он поддерживает распределённый трейсинг и хорошо интегрируется с Java, C# и RabbitMQ. 
Данные будут передаваться в Jaeger или Zipkin для визуализации и анализа.

### Реализация

1. Добавить OpenTelemetry SDK в:

    - Shop API (Spring Boot)
    - CRM API (Spring Boot)
    - MES API (C#)

2. Настроить интеграцию OpenTelemetry с RabbitMQ, чтобы отслеживать время доставки сообщений и количество повторных попыток.

3. Добавить middleware для логирования и трассировки запросов в интернет-магазине, CRM и MES.

4. Развернуть Jaeger/Zipkin в облачной инфраструктуре для сбора и анализа трейсинговых данных.

5. Настроить дашборды в Grafana для визуального мониторинга задержек обработки заказов.

### Доработанная диаграмма

Ссылка на обновлённую диаграмму: ссылка на доработанный C4
[Диаграмма контекста](обновленная-диаграмма.puml)

### Компромиссы

    - Затраты на инфраструктуру: для хранения и обработки трейсинговых данных потребуется дополнительная мощность (например, базы данных и серверы для Jaeger/Zipkin).
    - Оверхед на производительность: включение трейсинга добавит нагрузку на системы (~5-10% дополнительной задержки на обработку запросов).
    - Сложность поддержки: необходимо обучить команду работать с OpenTelemetry и анализировать данные в Jaeger/Zipkin.

### Безопасность

    - Аутентификация и авторизация: доступ к системе трейсинга будет ограничен ролями (например, только для администраторов и инженеров поддержки).
    - Фильтрация данных: исключение из трейсинга чувствительных данных (например, персональных данных клиентов).
    - Шифрование данных: передача данных в трейсинговую систему по HTTPS.
    - Логирование доступа: ведение журнала доступа к трейсинговым данным.

#### Вот доработанная UML-схема с учетом внедрения системы трейсинга. 
#### Добавил Distributed Tracing System (например, Jaeger или OpenTelemetry) и обновил связи, чтобы API-сервисы отправляли данные в систему трейсинга.

Добавленные элементы:
Tracing Service (Jaeger, OpenTelemetry)

    - Сбор логов и трассировка запросов через Shop API, CRM API, MES API
    - Мониторинг событий в RabbitMQ
    - Хранение данных в Elasticsearch (или Loki)

Обновленные связи:

    - Shop API → Tracing Service
    - CRM API → Tracing Service
    - MES API → Tracing Service
    - RabbitMQ → Tracing Service

#### Объяснение доработок

Tracing Service (Jaeger, OpenTelemetry)

    - Подключается к API-сервисам и очередям сообщений (RabbitMQ)
    - Собирать трассировки запросов, фиксировать задержки и ошибки
    - Позволит отследить путь заказа через систему

Log Storage (Elasticsearch, Loki)

    - Хранит трассировочные данные
    - Используется для поиска аномалий и отладки

Связи между компонентами

    - API-сервисы отправляют данные в Tracing Service
    - RabbitMQ логирует события в Tracing Service
    - Tracing Service записывает данные в Log Storage

Эта схема обеспечит полный контроль над перемещением заказов и поможет оперативно выявлять проблемы в системе.